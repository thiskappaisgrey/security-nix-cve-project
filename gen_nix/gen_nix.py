#FIXME: Need to reorganize python directories
from string import Template
from pathlib import Path
import subprocess
import argparse
import shutil

# Given the revision of nixpkgs, generate the url:
# rev: nixpkgs revision
def gen_nix_url(rev: str) -> str:
    return f"github:NixOS/nixpkgs/{rev}"

# For the basic template..
# There are ad-hoc commands if all you want is just 1 application
# but it's more scalabe if we also want to run other tools and such as well..?

# Basically - the inputs to this are just:
# url: the URL of nixpkgs contains the specific version of that pkg
# pkg: the package in question
# outdir: what directory to generate the package
def print_basic_template(url: str, pkg: str, outdir: str):
        with open("./templates/basic.nix") as f:
            s = f.read()
            template = Template(s)
            # TODO the url depends on 
            out = (template.substitute(url=f'"{url}"', pkg=pkg))
            print(f"Generating the nix file to: {outdir}")
            outpath = Path(outdir)
            if outpath.exists():
                print(f"{outdir} exists. Please remove it and try again")
                # TODO should exit here but it shouldn't matter too much
            outpath.mkdir(exist_ok=True)
            file = outpath / 'flake.nix'
            file.open('w').write(out)

            print(f"""Now run:
cd {outdir}; nix develop

To get your development environment!
            """)
            # with open(file, ) as f1: 
def get_server_template(url: str, pythonPackages: str, appname: str, config: str) -> str:
        # TODO: This path is a bit fragile..?
        dir = Path(__file__).parent.resolve()
        s = (dir / "templates" / "web-app.nix").read_text()
        template = Template(s)
        out = (template.substitute(url=f'"{url}"', 
                                       pythonPackages  = pythonPackages, 
                                       appname = appname,
                                       config = config,
                                       portsToOpen = "9000"
                                       ))
        return out

def generate_nix(generated_template: str, outdir: str):
            print(f"Generating the nix file to: {outdir}")
            outpath = Path(outdir)
            if outpath.exists():
                print(f"{outdir} exists. Please remove it and try again")
            outpath.mkdir(exist_ok=True)
            # Format the output with nixfmt
            p = subprocess.run(["nixfmt"], input=generated_template.encode(), capture_output=True)
            if p.returncode != 0:
                print("Invalid generated nix file - failing")
                exit(1)
            file = outpath / 'flake.nix'
            file.write_bytes(p.stdout)
            # TODO: Potentially also format the file for readability as well?

#             print(f"""Now run:
# cd {outdir}; nix develop
#
# To get your development environment!
#             """)
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Attempt Automatically generate a nix config from an exploit.py')
    parser.add_argument('-e', '--exploit', help='Specify the exploit file', required=True)
    parser.add_argument('-o', '--outdir', help='Specify the output file directory', required=True)
    args = parser.parse_args()
    exploit = Path(args.exploit)
    outdir = args.outdir
    if not exploit.exists():
        print("Exploit file doesn't exist! Can't get metadata")
        exit(1)
    # TODO: Do a bunch of stuff to get the metadata from exploit

    pythonPackages = "requests minio"
    appname = "minio"

    #TODO: Access key and other stuff can't be empty - idk how AI can deal with that..?
    config = "enable = true;listenAddress=\":9000\";\naccessKey=\"minioadmin\";secretKey=\"minioadmin\";"
    
    # The url is from the minio version
    url = "github:NixOS/nixpkgs/34bfa9403e42eece93d1a3740e9d8a02fceafbca"
    template = get_server_template(url, pythonPackages, appname, config)
    
    generate_nix(template, outdir)
    # Assume that outdir exists
    p = Path(outdir) / "exploit.py"
    # exploit.copy2(p)
    p.write_bytes(exploit.read_bytes())

